# Intro

Pada umumnya ketika membuat aplikasi khusus di backend sering mengenal dengan konsep *Dependency Injection* (DI). DI merupakan konsep dimana sebuah object membutuhkan object lain. Seperti contoh misal controller membutuhkan service dan service membutuhkan repository.

Untuk membuat dependency injection biasanya membutuhkan constructor, namun karena di golang tidak berbasis object oriented maka constructor dilakukan dengan menggunakan function.

Untuk melakukan dependency injection secara cepat biasanya menggunakan library :

1. google wire
2. uber-go fx
3. golobby container.

Untuk sesi ini akan menggunakan google wire. Lalu untuk base menggunakan project dari restful api

## Instalasi Google Wire
Untuk instalasi goggle wire:
```shell
go get github.com/google/wire
```

Kemudian agar lebih enak , install wire cli:
```shell
go install github.com/google/wire/cmd/wire@latest
```

Jikalau sudah terinstall, maka pada commmand line coba ketik wire help. Jika muncul artinya sudah berhasil diinstal.

## Provider
Pada google wire, constructor disebut sebagai provider.

Contoh implementasi :
```go
package simple

// create repository provider
type SimpleRepository struct {
}

func NewSimpleRepository() *SimpleRepository {
	return &SimpleRepository{}
}

// create service provider
type SimpleService struct {
	*SimpleRepository
}

func NewSimpleService(simpleRepository *SimpleRepository) *SimpleService {
	return &SimpleService{SimpleRepository: simpleRepository}
}
```

## Injector
Setelah membuat provider, selanjutnya membuat injector. Injector merupakan function constructor namun berisi configuration untuk Google Wire. Untuk melakukan proses tersebut perlu penambahan komentar:
```go
//go:build wireinject
//+build wireinjec
```

Contoh implementasi:
```go
//go:build wireinject
// +build wireinject

package simple

import "github.com/google/wire"

func InitializedService() *SimpleService {
	wire.Build(
		NewSimpleRepository,
		NewSimpleService,
	)
	return nil
}
```

## Dependency Injection
Setelah membuat provider, dan injector maka selanjutnya adalah mengenerate dependency injection dengan command line Google Wire.

Untuk mengenerate , masuk ke folder yang ada injector, kemudian ketik:
```shell
wire
```

Maka secara otomatis akan tergenerate file : wire_gen.go
```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package simple

// Injectors from injector.go:

func InitializedService() *SimpleService {
	simpleRepository := NewSimpleRepository()
	simpleService := NewSimpleService(simpleRepository)
	return simpleService
}
```

File tersebut jangan diutak atik.

Contoh penggunaan:
```go
func TestSimpleService(t *testing.T) {
	var simpleService *simple.SimpleService = simple.InitializedService()
	fmt.Println(simpleService.SimpleRepository)
}
```

## Error
Ada kondisi dimana ketika melakukan dependency injection terjadi error. Hal ini sudah di predict oleh Google Wire. 

Contoh implementasi:
```go
package simple

import "errors"

// create repository provider
type SimpleRepository struct {
	Error bool
}

func NewSimpleRepository() *SimpleRepository {
	return &SimpleRepository{}
}

// create service provider
type SimpleService struct {
	*SimpleRepository
}

func NewSimpleService(repository *SimpleRepository) (*SimpleService, error) {
	if repository.Error {
		return nil, errors.New("Failed to create service")
	} else {
		return &SimpleService{
			repository,
		}, nil
	}
}
```

Kemudian pada injector:
```go
func InitializedService() (*SimpleService, error) {
	wire.Build(
		NewSimpleRepository,
		NewSimpleService,
	)
	return nil, nil
}
```
Ketika digenerate code nya menggunakan wire maka hasilnya seperti ini:
```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package simple

// Injectors from injector.go:

func InitializedService() (*SimpleService, error) {
	simpleRepository := NewSimpleRepository()
	simpleService, err := NewSimpleService(simpleRepository)
	if err != nil {
		return nil, err
	}
	return simpleService, nil
}
```

Lalu untuk penggunaanya juga berubah:
```go
func TestSimpleService(t *testing.T) {
	simpleService, err := simple.InitializedService()
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(simpleService.SimpleRepository)
}
```

## Injector Parameter
Saat membuat injector, terkadang butuh parameter yang dinamis. Hal ini bisa dilakukan oleh google wire untuk memasukkan parameter dinamis di injector. 

Contoh implementasi:
```go
type SimpleRepository struct {
	Error bool
}

func NewSimpleRepository(isError bool) *SimpleRepository {
	return &SimpleRepository{
		Error: isError,
	}
}
```

Kemudian harus diubah juga pada injector:
```go
func InitializedService(isError bool) (*SimpleService, error) {
	wire.Build(
		NewSimpleRepository,
		NewSimpleService,
	)
	return nil, nil
}
```
Pada injector hanya memasukkan parameternya saja, tidak perlu memasukkan pada build. Kemudian jalankan wire kembali.

Untuk penggunaanya:
```go
func TestSimpleServiceError(t *testing.T) {
	simpleService, err := simple.InitializedService(true)
	assert.Nil(t, simpleService)
	assert.NotNil(t, err)
}

func TestSimpleServiceSuccess(t *testing.T) {
	simpleService, err := simple.InitializedService(false)
	assert.NotNil(t, simpleService)
	assert.Nil(t, err)
}
```

## Multiple Binding
Saat melakukan dependency injection, kadang ada kasus dimana membuat beberapa provider dengan tipe yang sama. Google wire tidak mendukung untuk multiple binding, oleh karena itu perlu dilakukan aliasing.

Contoh implementasi:
```go
// init database
type Database struct {
	Name string
}

// create aliasing
type DatabasePostgreSQL Database
type DatabaseMongoDB Database

func NewDatabaseMongoDB() *DatabaseMongoDB {
	return (*DatabaseMongoDB)(&Database{
		Name: "Mongodb",
	})
}

func NewDatabasePostgreSQL() *DatabasePostgreSQL {
	return (*DatabasePostgreSQL)(&Database{
		Name: "PostgreSQL",
	})
}

// init database repository
type DatabaseRepository struct {
	DatabasePostgreSQL *DatabasePostgreSQL
	DatabaseMongoDB    *DatabaseMongoDB
}

func NewDatabaseRepository(
	databasePostgreSQL *DatabasePostgreSQL,
	databaseMongoDB *DatabaseMongoDB,
) *DatabaseRepository {
	return &DatabaseRepository{DatabasePostgreSQL: databasePostgreSQL, DatabaseMongoDB: databaseMongoDB}
}
```

Kemudian pada injector:
```go
func InitializedDatabaseRepository() *DatabaseRepository {
	wire.Build(
		NewDatabaseMongoDB,
		NewDatabasePostgreSQL,
		NewDatabaseRepository,
	)

	return nil
}
```

Ketika dijalankan wire, maka hasilnya:
```go
func InitializedDatabaseRepository() *DatabaseRepository {
	databasePostgreSQL := NewDatabasePostgreSQL()
	databaseMongoDB := NewDatabaseMongoDB()
	databaseRepository := NewDatabaseRepository(databasePostgreSQL, databaseMongoDB)
	return databaseRepository
}
```

## Provider Set
Provider set berfungsi untuk mengroupkan semua provider sehingga akan lebih mudah untuk dibaca.

Sebagai contoh , akan dibuat provider foo dan bar.

foo.go
```go
package simple

type FooRepository struct {
}

func NewFooRepository() *FooRepository {
	return &FooRepository{}
}

type FooService struct {
	*FooRepository
}

func NewFooService(fooRepository *FooRepository) *FooService {
	return &FooService{FooRepository: fooRepository}
}
```

bar.go
```go
package simple

type BarReposiotry struct {
}

func NewBarReposiotry() *BarReposiotry {
	return &BarReposiotry{}
}

type BarService struct {
	*BarReposiotry
}

func NewBarService(barReposiotry *BarReposiotry) *BarService {
	return &BarService{BarReposiotry: barReposiotry}
}
```

kemudian buat constructor untuk foobar service
```go
type FooBarService struct {
	*FooService
	*BarService
}

func NewFooBarService(fooService *FooService, barService *BarService) *FooBarService {
	return &FooBarService{FooService: fooService, BarService: barService}
}
```

Kemudian pada code injector:
```go
var fooSet = wire.NewSet(NewFooRepository, NewFooService)

var barSet = wire.NewSet(NewBarReposiotry, NewBarService)

func InitializedFooBarService() *FooBarService {
	wire.Build(fooSet, barSet, NewFooBarService)
	return nil
}
```
Jalankan wire, maka secara otomatis akan tergenerate.

## Binding Interface
Pada pembuatan aplikasi , biasanya akan sering digunakan interface sebagai kontrak struct. By default, google wire akan menggunakan tipe data asli untuk melakukan dependency injection. Jikalau parameter yang dilempar merupakan interface dan tidak ada provider yang mengembalikan interface tersebut maka akan terjadi error. Oleh karena itu kita bisa memberi tahu sebuah interface akan menggunakan provider dengan tipe apa.

Contoh implementasi:
```go
package simple

// create sayhello interface and implementation
type SayHello interface {
	Hello(name string) string
}

type SayHelloImpl struct {
}

func (s *SayHelloImpl) Hello(name string) string {
	return "Hello " + name
}

// create HelloService from interface
type HelloService struct {
	SayHello SayHello
}

// create constructor SayHelloImpl and Hello Service
func NewSayHelloImpl() *SayHelloImpl {
	return &SayHelloImpl{}
}

func NewHelloService(sayHello SayHello) *HelloService {
	return &HelloService{SayHello: sayHello}
}
```
Pada code diatas, ketika digenerate akan terjadi error. Hal ini disebabkan karena google wire mendapati bahwa HelloService membutuhkan parameter SayHello bukan SayHelloImpl. Tetapi SayHello sendiri merupakan interface sehingga bukan provider. Oleh karena itu perlu diberitahu adanya interface pada google wire dengan cara binding.

implementasi:
```go
var helloSet = wire.NewSet(
	NewSayHelloImpl,
	wire.Bind(new(SayHello), new(*SayHelloImpl)),
)

func InitializedHelloService() *HelloService {
	wire.Build(helloSet, NewHelloService)
	return nil
}
```

Jadi pada code diatas kita buat set terlebih dahulu dengan isi NewSayHelloImpl dan bind SayHello dan *SayHelloImpl
Hal ini bertujuan untuk memberi tahu ketika dibutuhkan SayHello maka pointer data nya adalah SayHelloImpl. Sehingga ketika digabungkan antara HelloService dengan SayHello, maka HelloService tersebut akan memanggil si *SayHelloImpl.